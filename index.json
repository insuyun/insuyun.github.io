[{"authors":null,"categories":null,"content":"Insu Yun is an associate professor (untenured) at KAIST, currently leading Hacking Lab. He is interested in system security in general, especially, binary analysis, automatic vulnerability detection, and automatic exploit generation. His work has been published to the major computer conferences such as IEEE Security \u0026amp; Privacy, USENIX Security, and USENIX OSDI. Particularly, his research won the best paper award from USENIX Security and OSDI in 2018.\nIn addition to research, he has been participating in several hacking competitions as a hacking expert. In particular, he won Pwn2Own 2020 by compromising Apple Safari and won DEFCON CTF in 2015 and 2018, which is the world hacking competition.\nPrior to joining KAIST, he received his Ph.D. degree in Computer Science from Georgia Tech in 2020.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Insu Yun is an associate professor (untenured) at KAIST, currently leading Hacking Lab. He is interested in system security in general, especially, binary analysis, automatic vulnerability detection, and automatic exploit generation.","tags":null,"title":"Insu Yun (윤인수)","type":"authors"},{"authors":["Jihee Park","Insu Yun","Sukyoung Ryu"],"categories":[],"content":"","date":1759276800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1734570070,"objectID":"987ca8b2ee907166c7598d36d54e5156","permalink":"https://insuyun.github.io/publication/park-fible/","publishdate":"2024-12-19T01:01:10.778954Z","relpermalink":"/publication/park-fible/","section":"publication","summary":"","tags":[],"title":"Bridging the Gap between Real-World and Formal Binary Lifting through Filtered-Simulation (to appear)","type":"publication"},{"authors":["Taisic Yun","Suhwan Jeong","Yonghwa Lee","Seungjoo Kim","Hyoungshick Kim","Insu Yun","Yongdae Kim"],"categories":[],"content":"","date":1754006400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1752407400,"objectID":"650a9660c1558261bf52ce184683386f","permalink":"https://insuyun.github.io/publication/yun-ksa/","publishdate":"2025-07-13T11:50:00.56768Z","relpermalink":"/publication/yun-ksa/","section":"publication","summary":"","tags":[],"title":"Too Much of a Good Thing: (In-)Security of Mandatory Security Software for Financial Services in South Korea (to appear)","type":"publication"},{"authors":["Sujin Han","Jinseo Kim","Sung-Ju Lee","Insu Yun"],"categories":[],"content":"","date":1748736000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1752407812,"objectID":"ab318a27b6af6374f54da586c34092e9","permalink":"https://insuyun.github.io/publication/han-cpmm/","publishdate":"2025-07-13T11:56:52.078083Z","relpermalink":"/publication/han-cpmm/","section":"publication","summary":"Decentralized Finance (DeFi) enables many novel applications that were impossible in traditional finances. However, it also introduces new types of vulnerabilities. An example of such vulnerabilities is a composability bug between token contracts and Decentralized Exchange (DEX) that follows the Constant Product Market Maker (CPMM) model. This type of bug, which we refer to as CPMM composability bug, originates from issues in token contracts that make them incompatible with CPMMs, thereby endangering other tokens within the CPMM ecosystem. Since 2022, 23 exploits of such kind have resulted in a total loss of 2.2M USD. BlockSec, a smart contract auditing company, reported that 138 exploits of such kind occurred just in February 2023.\n\nIn this paper, we propose CPMMX , a tool that automatically detects CPMM composability bugs across\nentire blockchains. To achieve such scalability, we first formalized CPMM composability bugs and found that these bugs can be induced by breaking two safety invariants. Based on this finding, we designed CPMMX equipped with a two-step approach, called shallow-then-deep search. In more detail, it first uses shallow search to find transactions that break the invariants. Then, it uses deep search to refine these transactions, making them profitable for the attacker. We evaluated CPMMX against five baselines on two public datasets and one synthetic dataset. In our evaluation, CPMMX detected 2.5x to 1.5x more vulnerabilities compared to baseline methods. It also analyzed contracts significantly faster, achieving higher F1 scores than the baselines. Additionally, we applied CPMMX to all contracts on the latest blocks of the Ethereum and Binance networks and discovered 26 new exploits that can result in 15.7K USD profit in total.","tags":[],"title":"Automated Attack Synthesis for Constant Product Market Makers","type":"publication"},{"authors":["Suhwan Jeong","Beomseok Oh","Kwangmin Kim","Insu Yun","Yongdae Kim","CheolJun Park"],"categories":[],"content":"","date":1748736000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1752407812,"objectID":"8352b914024ce799184cb200c0839fed","permalink":"https://insuyun.github.io/publication/jeong-firmstate/","publishdate":"2025-07-13T11:56:51.972343Z","relpermalink":"/publication/jeong-firmstate/","section":"publication","summary":"Cellular baseband processors represent critical security components in modern\nmobile devices, yet they remain challenging to analyze due to their complexity\nand restricted access. While the FirmWire enables full-system baseband\nemulation, it lacks protocol state awareness, limiting its coverage and\nfidelity. While implementing such support demands substantial engineering\neffort, accurately modeling protocol states remains essential for comprehensive\nbaseband security analysis. In this paper, we present FirmState, a state-aware\nmethodology that augments baseband emulation, specifically targeting Samsung\nShannon baseband. FirmState semiautomatically recovers and applies state\ninformation extracted from physical devices during actual network\ncommunication, enabling more complete code coverage and authentic behavior\nreproduction without extensive reverse engineering. Our evaluation demonstrates\na significant improvement in code coverage, achieving 7.5% for RRC–2.7× higher\nthan previous work. Additionally, our system newly supports NAS over FirmWire,\nwith code coverage ranging from 4.5% to 9.2%, depending on the protocol state.\nUsing our approach, we discovered and analyzed two 1-day vulnerabilities in\nSamsung’s baseband implementation, demonstrating FirmState’s effectiveness for\nbaseband security. We make FirmState opensource to support further research in\nbaseband security.\n","tags":[],"title":"FirmState: Bringing Cellular Protocol States to Shannon Baseband Emulation","type":"publication"},{"authors":["Suhwan Jeong","Beomseok Oh","Kwangmin Kim","Insu Yun","Yongdae Kim","CheolJun Park"],"categories":[],"content":"","date":1748736000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1746245772,"objectID":"8762bac641584cd3527365541bc5c298","permalink":"https://insuyun.github.io/publication/jung-firmstate/","publishdate":"2025-05-03T04:16:12.38002Z","relpermalink":"/publication/jung-firmstate/","section":"publication","summary":"","tags":[],"title":"FirmState: Bringing Cellular Protocol States to Shannon Baseband Emulation (to appear)","type":"publication"},{"authors":["Junyoung Park","Yunho Kim","Insu Yun"],"categories":[],"content":"","date":1746057600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1752407401,"objectID":"f9bb93f7f142011fd912786108b592e4","permalink":"https://insuyun.github.io/publication/park-rgfuzz/","publishdate":"2025-07-13T11:50:01.066067Z","relpermalink":"/publication/park-rgfuzz/","section":"publication","summary":"WebAssembly runtimes embed compilers to compile WebAssembly code into machine code for execution. These compilers use various compiler rules to define how to optimize and lower the WebAssembly code. However, existing testing tools struggle to explore these rules effectively due to their complexity. Moreover, they cannot generate test cases diversely due to their limitations, which can result in undetected bugs.\n\nThis paper presents RGFuzz, a differential fuzzer for WebAssembly runtimes, addressing the existing limitations through two novel techniques. First, RGFuzz uses rule-guided fuzzing, which extracts compiler rules from the WebAssembly runtime, wasmtime, and uses them to guide test case generation, thereby effectively exploring complex rules. Second, RGFuzz uses reverse stack-based generation to generate test cases diversely. These techniques enable RGFuzz to find bugs effectively in WebAssembly runtimes. We implemented RGFuzz and evaluated it on six engines: wasmtime, Wasmer, WasmEdge, V8, SpiderMonkey, and JavaScriptCore. As a result, RGFuzz found 20 new bugs in these engines, including one bug with a CVE ID issued. Our evaluation demonstrates that RGFuzz outperforms existing fuzzers by utilizing the extracted rules and diversely generating test cases.","tags":[],"title":"RGFuzz: Rule-Guided Fuzzer for WebAssembly Runtimes","type":"publication"},{"authors":["Haein Lee","Insu Yun"],"categories":[],"content":"","date":1714521600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1722433304,"objectID":"353172c8509025873c6bd973f46dddcc","permalink":"https://insuyun.github.io/publication/lee-v-8-ctf/","publishdate":"2024-07-31T13:41:44.821846Z","relpermalink":"/publication/lee-v-8-ctf/","section":"publication","summary":"In today’s digital era, where the internet has become as essential as the air we breathe, the browsers serve as our windows to the vast expanse of the digital world. On top of web surfing, browsers extend their capabilities from being integrated into embedded systems to supporting desktop apps. Browsers are fascinating targets because they are widely used for user interaction, hence browser exploits are frequently utilized in exploit chains. Inspired by the big success of kernelCTF, Google launched v8CTF to gather exploit techniques in the V8 JavaScript engine by rewarding 0day/1day exploits, thereby encouraging security engineers.\n\nIn this talk, we will discuss our exploit, which was the second valid submission in the history of v8CTF. To achieve this, we utilized a 1-day vulnerability identified as CVE-2023-6702. Unlike other vulnerabilities, this one is quite unique. It causes a type confusion between a 4-byte hash value and a V8 heap object. This vulnerability, which may have been infeasible to exploit in the past, has become exploitable due to the recent introduction of pointer compression in V8. To exploit this vulnerability, we applied a variety of techniques and successfully achieved a remote code execution with nearly a 100% success rate.","tags":[],"title":"From the Vulnerability to the Victory: A Chrome Renderer 1-Day Exploit’s Journey to v8CTF Glory","type":"publication"},{"authors":["Dongok Kim","Seunghyun Lee","Insu Yun"],"categories":[],"content":"","date":1698796800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1722433304,"objectID":"3266650b61067c22f27462dfa195fd60","permalink":"https://insuyun.github.io/publication/kim-kernel-ctf/","publishdate":"2024-07-31T13:41:44.896788Z","relpermalink":"/publication/kim-kernel-ctf/","section":"publication","summary":"Desktops, servers, cloud computing services, mobile devices, and IoT devices. Linux is the most popular open-source kernel and is used in various IT platforms. Because of the ubiquitous presence of Linux and the characteristic of the kernel which governs the entire system, security threat against Linux kernel is a significant concern. Numerous vulnerabilities in Linux are reported frequently, either discovered by fuzzer or through manual analysis. However, assessing the exploitability of these vulnerabilities is not a straightforward task these days, where various mitigations are applied.\n\nTo address these issues, Google recently announced kernelCTF — a bug bounty program that is specifically designed for studying Linux kernel exploits. kernelCTF originated from kCTF, which initially was a bug bounty program for GKE (Google Kubernetes Engine). Then, it has evolved into kernelCTF, to provide an environment for kernel security researchers to actively engage in vulnerability identification and exploit mitigations. For the intention of the program, kernelCTF provides various targets such as the latest LTS Linux kernel, Container-optimized OS (COS) used for GKE, and LTS Linux kernel with Google’s custom kernel exploit mitigations. Unlike other bug bounty programs, Google considers submissions as valid regardless of whether the vulnerability is 0-day or 1-day if they can successfully achieve full LPE kernel exploits with container escape.\n\nIn this talk, we will present our exploits submitted to kernelCTF. Notably, this is the first submission in kernelCTF's history that exploits every target with a single (1-day) vulnerability. We will briefly introduce what kernelCTF is and each target kernel instance of kernelCTF. Then, we will explain how we built the 1-day vulnerability exploit for every target instance in detail. This will include how we discovered this vulnerability, and how we made exploits working for the different target kernel versions, build configs, and applied mitigations. Finally, we will share our novel research and insights into kernel exploit mitigations of Linux and Google, focusing on their limitations and side effects. We will also discuss the difficulties to apply mitigations to the Linux kernel.","tags":[],"title":"One shot, Triple kill: Pwning all three Google kernelCTF instances with a single 1-day Linux vulnerability","type":"publication"},{"authors":["Eunsoo Kim","Min Woo Baek","CheolJun Park","Dongkwan Kim","Yongdae Kim","Insu Yun"],"categories":[],"content":"","date":1690848000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1693524670,"objectID":"7be86fdd9794399344b106e4513f0887","permalink":"https://insuyun.github.io/publication/kim-basecomp/","publishdate":"2023-08-31T23:31:10.190803Z","relpermalink":"/publication/kim-basecomp/","section":"publication","summary":"","tags":[],"title":"BaseComp: A Comparative Analysis for Integrity Protection in Cellular Baseband Software","type":"publication"},{"authors":["HyungSeok Han","JeongOh Kyea","Yonghwi Jin","Jinoh Kang","Brian Park","Insu Yun"],"categories":[],"content":"","date":1682899200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1686057363,"objectID":"873095d800396834ebd550a65ba08cdd","permalink":"https://insuyun.github.io/publication/han-queryx/","publishdate":"2023-06-06T13:16:03.808075Z","relpermalink":"/publication/han-queryx/","section":"publication","summary":"","tags":[],"title":"QueryX: Symbolic Query on Decompiled Code for Finding Bugs in COTS Binaries","type":"publication"},{"authors":["Juhyeng Han","Insu Yun","Seongmin Kim","Taesoo Kim","Sooel Son","Dongsu Han"],"categories":[],"content":"","date":1667260800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1686057363,"objectID":"743021bb0af3a78f05a88eb0ceb9ae03","permalink":"https://insuyun.github.io/publication/han-sectrust/","publishdate":"2023-06-06T13:16:03.8753Z","relpermalink":"/publication/han-sectrust/","section":"publication","summary":"","tags":[],"title":"Scalable and Secure Virtualization of HSM with ScaleTrust","type":"publication"},{"authors":["Daehee Jang","Ammar Askar","Insu Yun","Stephen Tong","Yiqin Cai","Taesoo Kim"],"categories":[],"content":"","date":1664582400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1668108180,"objectID":"343332e06f9f7c700c42e6bd628e4539","permalink":"https://insuyun.github.io/publication/jang-fuzzcoin/","publishdate":"2022-11-10T19:23:00.021042Z","relpermalink":"/publication/jang-fuzzcoin/","section":"publication","summary":"","tags":[],"title":"Fuzzing@Home: Distributed Fuzzing on Untrusted Heterogeneous Clients","type":"publication"},{"authors":["CheolJun Park","Sangwook Bae","BeomSeok Oh","Jiho Lee","Eunkyu Lee","Insu Yun","Yongdae Kim"],"categories":[],"content":"","date":1659312000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1668108180,"objectID":"aa5e1ecf7c44003decd682564d01aa6f","permalink":"https://insuyun.github.io/publication/park-doltest/","publishdate":"2022-11-10T19:23:00.091774Z","relpermalink":"/publication/park-doltest/","section":"publication","summary":"","tags":[],"title":"DoLTEst: In-depth Downlink Negative Testing Framework for LTE Devices","type":"publication"},{"authors":["Insu Yun","Woosun Song","Seunggi Min","Taesoo Kim"],"categories":[],"content":"","date":1635724800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595647,"objectID":"07c6d1bfa89aea117211c00b41e36ce3","permalink":"https://insuyun.github.io/publication/yun-hardsheap/","publishdate":"2022-08-04T06:47:27.55693Z","relpermalink":"/publication/yun-hardsheap/","section":"publication","summary":"Secure allocators have been extensively studied to mitigate heap\nvulnerabilities. They employ safe designs and randomized mechanisms to stop or\nmitigate heap exploitation. Despite extensive research efforts, secure\nallocators can only be evaluated by with theoretical analysis or pre-defined\ndata sets, which are insufficient to effectively reflect powerful adversaries in\nthe real world.\n\nIn this paper, we present HardsHeap, an automatic tool for evaluating secure\nallocators. The key idea of HardsHeap is to use random testing (i.e., fuzzing)\nto evaluate secure allocators. To handle the diverse properties of secure\nallocators, HardsHeap supports an extensible framework, making it easy to write\na validation logic for each property. Moreover, HardsHeap employs sampling-based\ntesting, which enables us to evaluate a probabilistic mechanism prevalent in\nsecure allocators. To eliminate redundancy in findings from HardsHeap, we devise\na new technique called Statistical Significance Delta Debugging (SSDD), which\nextends the existing delta debugging for stochastically reproducible test cases.\n\nWe evaluated HardsHeap to 10 secure allocators. Consequently, we found 56\ninteresting test cases, including several unsecure yet underestimated behaviors\nfor handling large objects in secure allocators. Moreover, we discovered 10\nimplementation bugs. One of the bugs is integer overflow in secure allocators,\nmaking them even more invulnerable than ordinary allocators. Our evaluation also\nshows that SSDD successfully reduces test cases by 37.2% on average without a\nloss of reproducibility.\n","tags":[],"title":"HardsHeap: A Universal and Extensible Framework for Evaluating Secure Allocators","type":"publication"},{"authors":["Brian Wickman","Hong Hu","Insu Yun","Daehee Jang","JungWon Lim","Sanidhya Kashyap","Taesoo Kim"],"categories":[],"content":"","date":1627776000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595647,"objectID":"e5a4daf0be1274bec71d1ce6564c04b7","permalink":"https://insuyun.github.io/publication/wickman-ffmalloc/","publishdate":"2022-08-04T06:47:27.693721Z","relpermalink":"/publication/wickman-ffmalloc/","section":"publication","summary":"Memory-unsafe languages are widely used to implement critical systems like kernels and browsers, leading to thousands of memory safety issues every year. A use-after-free bug is a temporal memory error where the program accidentally visits a freed memory location. Recent studies show that useafter-free is one of the most exploited memory vulnerabilities. Unfortunately, previous efforts to mitigate use-after-free bugs are not widely deployed in real-world programs due to either inadequate accuracy or high performance overhead.\n\nIn this paper, we propose to resurrect the idea of one-time allocation (OTA) and provide a practical implementation with efficient execution and moderate memory overhead. With onetime allocation, the memory manager always returns a distinct memory address for each request. Since memory locations are not reused, attackers cannot reclaim freed objects, and thus cannot exploit use-after-free bugs. We utilize two techniques to render OTA practical: batch page management and the fusion of bump-pointer and fixed-size bins memory allocation styles. Batch page management helps reduce the number of system calls which negatively impact performance, while blending the two allocation methods mitigates the memory overhead and fragmentation issues. We implemented a prototype, called FFmalloc, to demonstrate our techniques. We evaluated FFmalloc on widely used benchmarks and real-world large programs. FFmalloc successfully blocked all tested useafter-free attacks while introducing moderate overhead. The results show that OTA can be a strong and practical solution to thwart use-after-free threats.\n","tags":[],"title":"Preventing Use-After-Free Attacks with Fast Forward Allocation","type":"publication"},{"authors":["Hyunsik Jung","Insu Yun","Yongdae Kim"],"categories":[],"content":"","date":1622505600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1686057364,"objectID":"0c3910bbaa3f7b15ee5b77d6068b0382","permalink":"https://insuyun.github.io/publication/jung-hexagon/","publishdate":"2023-06-06T13:16:04.149207Z","relpermalink":"/publication/jung-hexagon/","section":"publication","summary":"","tags":[],"title":"Analyzing Qualcomm Hexagon Emulators via Differential Testing","type":"publication"},{"authors":["Eunsoo Kim","Dongkwan Kim","Cheoljun Park","Insu Yun","Yongdae Kim"],"categories":[],"content":"","date":1612137600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595647,"objectID":"55638d25edf40a0af6eaf83fd98ffa2d","permalink":"https://insuyun.github.io/publication/kim-basespec/","publishdate":"2022-08-04T06:47:27.761245Z","relpermalink":"/publication/kim-basespec/","section":"publication","summary":"Cellular basebands play a crucial role in mobile communication. However, it is significantly challenging to assess their security for several reasons. Manual analysis is inevitable because of the obscurity and complexity of baseband firmware; however, such analysis requires repetitive efforts to cover diverse models or versions. Automating the analysis is also non-trivial because the firmware is significantly large and contains numerous functions associated with complex cellular protocols. Therefore, existing approaches on baseband analysis are limited to only a couple of models or versions within a single vendor. In this paper, we propose a novel approach named BaseSpec, which performs a comparative analysis of baseband software and cellular specifications. By leveraging the standardized message structures in the specification, BaseSpec inspects the message structures implemented in the baseband software systematically. It requires a manual yet one-time analysis effort to determine how the message structures are embedded in target firmware. Then, BaseSpec compares the extracted message structures with those in the specification syntactically and semantically, and finally, it reports mismatches. These mismatches indicate the developer mistakes, which break the compliance of the baseband with the specification, or they imply potential vulnerabilities. We evaluated BaseSpec with 18 baseband firmware images of 9 models from one of the top three vendors and found hundreds of mismatches. By analyzing these mismatches, we discovered 9 erroneous cases: 5 functional errors and 4 memory-related vulnerabilities. Notably, two of these are critical remote code execution 0-days. Moreover, we applied BaseSpec to 3 models from another vendor, and BaseSpec found multiple mismatches, two of which led us to discover a buffer overflow bug.\n","tags":[],"title":"BaseSpec: Comparative Analysis of Baseband Software and Cellular Specifications for L3 Protocols","type":"publication"},{"authors":["Insu Yun"],"categories":[],"content":"","date":1606780800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595647,"objectID":"ad7f331fb7c111d0d32fa109d7260bc3","permalink":"https://insuyun.github.io/publication/yun-thesis/","publishdate":"2022-08-04T06:47:27.829508Z","relpermalink":"/publication/yun-thesis/","section":"publication","summary":"","tags":[],"title":"Concolic Execution Tailored for Hybrid Fuzzing","type":"publication"},{"authors":["Insu Yun","Dhaval Kapil","Taesoo Kim"],"categories":[],"content":"","date":1596240000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595647,"objectID":"ea8cb68cf4bf59c0580bce923e050c53","permalink":"https://insuyun.github.io/publication/yun-archeap/","publishdate":"2022-08-04T06:47:27.897973Z","relpermalink":"/publication/yun-archeap/","section":"publication","summary":"Exploitation techniques to abuse metadata of heap allocators have been widely studied because of their generality (i.e., application independence) and powerfulness (i.e., bypassing modern mitigation). However, such techniques are commonly considered arts, and thus the ways to discover them remain ad-hoc, manual, and allocator-specific.\n\nIn this paper, we present an automatic tool, ArcHeap, to systematically discover the unexplored heap exploitation primitives, regardless of their underlying implementations. The key idea of ArcHeap is to let the computer autonomously explore the spaces, similar in concept to fuzzing, by specifying a set of common designs of modern heap allocators and root causes of vulnerabilities as models, and by providing heap operations and attack capabilities as actions. During the exploration, ArcHeap checks whether the combinations of these actions can be potentially used to construct exploitation primitives, such as arbitrary write or overlapped chunks. As a proof, ArcHeap generates working PoC that demonstrates the discovered exploitation technique.\n\nWe evaluated ArcHeap with ptmalloc2 and 10 other allocators, and discovered five previously unknown exploitation techniques in ptmalloc2 as well as several techniques against seven out of 10 allocators including the security-focused allocator, DieHarder. To show the effectiveness of ArcHeap's approach in other domains, we also studied how security features and exploit primitives evolve across different versions of ptmalloc2.\n","tags":[],"title":"Automatic Techniques to Systematically Discover New Heap Exploitation Primitives","type":"publication"},{"authors":["Yonghwi Jin","Jungwon Lim","Insu Yun","Taesoo Kim"],"categories":[],"content":"","date":1596240000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595648,"objectID":"5d5f2c21ae76a5e24b82451a8b3db3b5","permalink":"https://insuyun.github.io/publication/jin-pwn-2-own-2020-safari/","publishdate":"2022-08-04T06:47:27.967392Z","relpermalink":"/publication/jin-pwn-2-own-2020-safari/","section":"publication","summary":"Compromising a kernel through a browser is the ultimate goal for offensive security researchers. Because of continuous efforts to eliminate vulnerabilities and introduce various mitigations, a remote kernel exploit from a browser becomes extremely difficult, seemingly impossible.\n\nIn this talk, we will share our Safari exploit submitted to Pwn2Own 2020. Combining *SIX* different vulnerabilities, our exploit successfully compromises the macOS kernel starting from the Safari browser. It breaks every mitigation in macOS including ASLR, DEP, sandbox, and even System Integrity Protection (SIP). Inspecting every vulnerability used in this exploit, we will show not only state-of-the-art hacking techniques but also challenges in protecting complicated systems (i.e., browsers and operating systems) and in introducing their mitigations. Moreover, we will introduce a new technique that reliably exploits a TOCTOU vulnerability in macOS.\n\n","tags":[],"title":"Compromising the macOS kernel through Safari by chaining six vulnerabilities","type":"publication"},{"authors":["Soyeon Park","Wen Xu","Insu Yun","Daehee Jang","Taesoo Kim"],"categories":[],"content":"","date":1588291200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1693524670,"objectID":"d5f355ce1e74a693994f2b8f3dc7a734","permalink":"https://insuyun.github.io/publication/park-die/","publishdate":"2023-08-31T23:31:10.926279Z","relpermalink":"/publication/park-die/","section":"publication","summary":"Fuzzing is a practical, widely-deployed technique to find bugs in complex, real-world programs like JavaScript engines. We observed, however, that existing fuzzing approaches, either generative or mutational, fall short in fully harvesting high-quality input corpora such as known proof of concept (PoC) exploits or unit tests. Existing fuzzers tend to destruct subtle semantics or conditions encoded in the input corpus in order to generate new test cases because this approach helps in discovering new code paths of the program. Nevertheless, for JavaScript-like complex programs, such a conventional design leads to test cases that tackle only shallow parts of the complex codebase and fails to reach deep bugs effectively due to the huge input space.\n\nIn this paper, we advocate a new technique, called an aspect-preserving mutation, that stochastically preserves the desirable properties, called aspects, that we prefer to be maintained across mutation. We demonstrate the aspect preservation with two mutation strategies, namely, structure and type preservation, in our fully-fledged JavaScript fuzzer, called DIE. Our evaluation shows that DIE's aspect-preserving mutation is more effective in discovering new bugs (5.7 x more unique crashes) and producing valid test cases (2.4 x fewer runtime errors) than the state-of-the-art JavaScript fuzzers. DIE newly discovered 48 high-impact bugs in ChakraCore, JavaScriptCore, and V8 (38 fixed with 12 CVEs assigned as of today). The source code of DIE is publicly available as an open-source project.\n","tags":[],"title":"Fuzzing JavaScript Engines with Aspect-preserving Mutation","type":"publication"},{"authors":["Weidong Cui","Xinyang Ge","Baris Kasikci","Ben Niu","Upamanyu Sharma","Ruoyu Wang","Insu Yun"],"categories":[],"content":"","date":1538352000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1693524803,"objectID":"6d57b4669ac9b8bb6de553e5361eb28c","permalink":"https://insuyun.github.io/publication/cui-rept/","publishdate":"2023-08-31T23:33:23.15Z","relpermalink":"/publication/cui-rept/","section":"publication","summary":"Debugging software failures in deployed systems is important because they\nimpact real users and customers. However, debugging such failures is\nnotoriously hard in practice because developers have to rely on limited\ninformation such as memory dumps. The execution history is usually unavailable\nbecause high-fidelity program tracing is not affordable in deployed systems.\n\nIn this paper, we present REPT, a practical system that enables reverse\ndebugging of software failures in deployed systems. REPT reconstructs the\nexecution history with high fidelity by combining online lightweight hardware\ntracing of a program's control flow with offline binary analysis that recovers\nits data flow. It is seemingly impossible to recover data values thousands of\ninstructions before the failure due to information loss and concurrent\nexecution. REPT tackles these challenges by constructing a partial execution\norder based on timestamps logged by hardware and iteratively performing forward\nand backward execution with error correction.\n\nWe design and implement REPT, deploy it on Microsoft Windows, and integrate it\ninto Windows Debugger. We evaluate REPT on 16 real-world bugs and show that it\ncan recover data values accurately (92% on average) and efficiently (less than\n20 seconds) for these bugs. We also show that it enables effective reverse\ndebugging for 14 bugs.\n","tags":[],"title":"REPT: Reverse Debugging of Failures in Deployed Software","type":"publication"},{"authors":["Insu Yun","Sangho Lee","Meng Xu","Yeongjin Jang","Taesoo Kim"],"categories":[],"content":"","date":1533081600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1693524803,"objectID":"eb5181f52b2a536fba3b5247c74d69b1","permalink":"https://insuyun.github.io/publication/yun-qsym/","publishdate":"2023-08-31T23:33:23.21401Z","relpermalink":"/publication/yun-qsym/","section":"publication","summary":"Recently, hybrid fuzzing has been proposed to address the limitations of\nfuzzing and concolic execution by combining both approaches. The hybrid\napproach has shown its effectiveness in various synthetic benchmarks such as\nDARPA Cyber Grand Challenge (CGC) binaries, but it still suffers from scaling\nto find bugs in complex, real-world software. We observed that the performance\nbottleneck of the existing concolic executor is the main limiting factor for\nits adoption beyond a small-scale study.\n\nTo overcome this problem, we design a fast concolic execution engine, called\nQSYM, to support hybrid fuzzing. The key idea is to tightly integrate the\nsymbolic emulation with the native execution using dynamic binary translation,\nmaking it possible to implement more fine-grained, so faster, instruction-level\nsymbolic emulation. Additionally, QSYM loosens the strict soundness\nrequirements of conventional concolic executors for better performance, yet\ntakes advantage of a faster fuzzer for validation, providing unprecedented\nopportunities for performance optimizations, e.g., optimistically solving\nconstraints and pruning uninteresting basic blocks.\n\nOur evaluation shows that QSYM does not just outperform state-of-the-art\nfuzzers (i.e., found 14× more bugs than VUzzer in the LAVA-M dataset, and\noutperformed Driller in 104 binaries out of 126), but also found 13 previously\nunknown security bugs in eight real-world programs like Dropbox Lepton, ffmpeg,\nand OpenJPEG, which have already been intensively tested by the\nstate-of-the-art fuzzers, AFL and OSS-Fuzz.\n","tags":[],"title":"QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing","type":"publication"},{"authors":["Jinho Jung","Chanil Jeon","Max Wolotsky","Insu Yun","Taesoo Kim"],"categories":[],"content":"","date":1498867200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595648,"objectID":"5d65636ac64d46bf505e232f1921811b","permalink":"https://insuyun.github.io/publication/jung-avpass/","publishdate":"2022-08-04T06:47:28.239646Z","relpermalink":"/publication/jung-avpass/","section":"publication","summary":"AVPASS is a tool for leaking the detection model \nof Android antivirus (AV) programs, and bypassing \nthe AV detection by using the leaked information \ncoupled with APK perturbation techniques. AVPASS \nis able to infer not only the detection features, \nbut also hierarchy of detection rule chains. \nWith help from the leaked model and the built-in \nAPK perturbation functions, AVPASS is able to \ndisguise any android malware as a benign application. \nFurthermore, using our novel additive mode, AVPASS \nsupports safe querying and guarantees that one can \ntest if the application will be detected by the AV \nwithout sending the whole or core parts of application. \nAs a result, AVPASS leaked significant detection \nfeatures of commercial AVs and achieved almost \nzero detection from VirusTotal when tested with \nmore than 5,000 malware. \n\nIn this talk, we present the entire pipeline of \nthe APK perturbation process, leaking model process, \nand auto-bypassing process. In addition, we show \nfindings about commercial AVs, including their \ndetection features and hierarchy, and inform the \nattendees about the potential weaknesses of modern AVs. \n\nAVPASS will be demonstrated, showing that it modifies \nreal world malware precisely, and allows them to \nbypass all AVs following the leaked model. AVPASS \nwill be released with every tool that we have built, \nincluding the original source code and the related \ntest data, to enable researchers to replicate the \nresearch on their own.\n\n","tags":[],"title":"AVPASS: Leaking and Bypassing Antivirus Detection Model Automatically","type":"publication"},{"authors":["Su Yong Kim","Sangho Lee","Insu Yun","Wen Xu","Byoungyoung Lee","Youngtae Yun","Taesoo Kim"],"categories":[],"content":"","date":1498867200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595648,"objectID":"071f0e16b1742a1a73d3981dd070583b","permalink":"https://insuyun.github.io/publication/kim-cab-fuzz/","publishdate":"2022-08-04T06:47:28.309451Z","relpermalink":"/publication/kim-cab-fuzz/","section":"publication","summary":"Discovering the security vulnerabilities of commercial off-the-shelf\n(COTS) operating systems (OSes) is challenging because they not only\nare huge and complex, but also lack detailed debug\ninformation. Concolic testing, which generates all feasible inputs of\na program by using symbolic execution and tests the program with the\ngenerated inputs, is one of the most promising approaches to solve\nthis problem. Unfortunately, the state-of-the-art concolic testing\ntools do not scale well for testing COTS OSes because of state\nexplosion. Indeed, they often fail to find a single bug (or crash) in\nCOTS OSes despite their long execution time.\n\nIn this paper, we propose CAB-Fuzz (Context-Aware and\nBoundary-focused), a practical concolic testing tool to quickly\nexplore interesting paths that are highly likely triggering real bugs\nwithout debug information. First, CAB-Fuzz prioritizes the boundary\nstates of arrays and loops, inspired by the fact that many\nvulnerabilities originate from a lack of proper boundary\nchecks. Second, CAB-Fuzz exploits real programs interacting with COTS\nOSes to construct proper contexts to explore deep and complex kernel\nstates without debug information. We applied CAB-Fuzz to Windows 7 and\nWindows Server 2008 and found 21 undisclosed unique crashes, including\ntwo local privilege escalation vulnerabilities (CVE2015-6098 and\nCVE-2016-0040) and one information disclosure vulnerability in a\ncryptography driver (CVE2016-7219). CAB-Fuzz found vulnerabilities\nthat are non-trivial to discover; five vulnerabilities have existed\nfor 14 years, and we could trigger them even in the initial version of\nWindows XP (August 2001).","tags":[],"title":"CAB-Fuzz: Practical Concolic Testing Techniques for COTS Operating Systems","type":"publication"},{"authors":["Insu Yun","Changwoo Min","Xujie Si","Yeongjin Jang","Taesoo Kim","Mayur Naik"],"categories":[],"content":"","date":1470009600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595648,"objectID":"f0a607f7b4f7d3016efd7822ea90ff21","permalink":"https://insuyun.github.io/publication/yun-apisan/","publishdate":"2022-08-04T06:47:28.378921Z","relpermalink":"/publication/yun-apisan/","section":"publication","summary":"API misuse is a well-known source of bugs. Some of them (e.g., incorrect use of\nSSL API, and integer overflow of memory allocation size) can cause serious\nsecurity vulnerabilities (e.g., man-in-the-middle (MITM) attack, and privilege\nescalation). Moreover, modern APIs, which are large, complex, and fast\nevolving, are error-prone. However, existing techniques to help finding bugs\nrequire manual effort by developers (e.g., providing specification or model) or\nare not scalable to large real-world software comprising millions of lines of\ncode.\n\nIn this paper, we present APISAN, a tool that automatically infers correct API\nusages from source code without manual effort. The key idea in APISAN is to\nextract likely correct usage patterns in four different aspects (e.g., causal\nrelation, and semantic relation on arguments) by considering semantic\nconstraints. APISAN is tailored to check various properties with security\nimplications. We applied APISAN to 92 million lines of code, including Linux\nKernel, and OpenSSL, found 76 previously unknown bugs, and provided patches for\nall the bugs.\n","tags":[],"title":"APISan: Sanitizing API Usages through Semantic Cross-checking","type":"publication"},{"authors":["Chengyu Song","Hyungon Moon","Monjur Alam","Insu Yun","Byoungyoung Lee","Taesoo Kim","Wenke Lee","Yunheung Paek"],"categories":[],"content":"","date":1462060800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595648,"objectID":"43a9d55ee3fcd955c2852af8602c367b","permalink":"https://insuyun.github.io/publication/song-hdfi/","publishdate":"2022-08-04T06:47:28.44733Z","relpermalink":"/publication/song-hdfi/","section":"publication","summary":"Memory corruption vulnerabilities are the root cause of many modern attacks. Existing defense mechanisms are inadequate; in general, the software-based approaches are not efficient and the hardware-based approaches are not flexible. In this paper, we present hardware-assisted data-flow isolation, or, Hdfi, a new fine-grained data isolation mechanism that is broadly applicable and very efficient. Hdfi enforces isolation at the machine word granularity by virtually extending each memory unit with an additional tag that is defined by data-flow. This capability allows Hdfi to enforce a variety of security models such as the Biba Integrity Model and the Bell--LaPadula Model. We implemented Hdfi by extending the RISC-V instruction set architecture (ISA) and instantiating it on the Xilinx Zynq ZC706 evaluation board. We ran several benchmarks including the SPEC CINT 2000 benchmark suite. Evaluation results show that the performance overhead caused by our modification to the hardware is low (","tags":[],"title":"HDFI: Hardware-Assisted Data-Fow Isolation","type":"publication"},{"authors":["Shinjo Park","Suwan Park","Insu Yun","Dongkwan Kim","Yongdae Kim"],"categories":[],"content":"","date":1406851200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595648,"objectID":"bdb710bfcd69afef03045dfbb77a815c","permalink":"https://insuyun.github.io/publication/park-pki/","publishdate":"2022-08-04T06:47:28.515803Z","relpermalink":"/publication/park-pki/","section":"publication","summary":"","tags":[],"title":"Analyzing Security of Korean USIM-based PKI Certificate Service","type":"publication"},{"authors":["Muhammad Jamshed","Jihyung Lee","Sangwoo Moon","Insu Yun","Deokjin Kim","Sungryoul Lee","Yung Yi","KyoungSoo Park"],"categories":[],"content":"","date":1349049600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659595648,"objectID":"d00a8a94be1b3114b7c34a37c5c721f6","permalink":"https://insuyun.github.io/publication/jamshed-kargus/","publishdate":"2022-08-04T06:47:28.582645Z","relpermalink":"/publication/jamshed-kargus/","section":"publication","summary":"As high-speed networks are becoming commonplace, it is increasingly challenging\nto prevent the attack attempts at the edge of the Internet. While many\nhigh-performance intrusion detection systems (IDSes) employ dedicated network\nprocessors or special memory to meet the demanding performance requirements, it\noften increases the cost and limits functional flexibility. In contrast,\nexisting softwarebased IDS stacks fail to achieve a high throughput despite\nmodern hardware innovations such as multicore CPUs, manycore GPUs, and 10 Gbps\nnetwork cards that support multiple hardware queues.\n\nWe present Kargus, a highly-scalable software-based IDS that exploits the full\npotential of commodity computing hardware. First, Kargus batch processes\nincoming packets at network cards and achieves up to 40 Gbps input rate even\nfor minimum-sized packets.  Second, it exploits high processing parallelism by\nbalancing the pattern matching workloads with multicore CPUs and heterogeneous\nGPUs, and benefits from extensive batch processing of multiple packets per each\nIDS function call. Third, Kargus adapts its resource usage depending on the\ninput rate, significantly saving the power in a normal situation. Our\nevaluation shows that Kargus on a 12-core machine with two GPUs handles up to\n33 Gbps of normal traffic and achieves 9 to 10 Gbps even when all packets\ncontain attack signatures, a factor of 1.9 to 4.3 performance improvements over\nthe existing state-of-the-art software IDS. We design Kargus to be compatible\nwith the most popular software IDS, Snort.\n","tags":[],"title":"Kargus: A Highly-scalable Software-based Intrusion Detection System","type":"publication"}]